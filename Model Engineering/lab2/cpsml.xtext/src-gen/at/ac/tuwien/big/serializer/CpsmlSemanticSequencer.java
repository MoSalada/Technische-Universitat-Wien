/*
 * generated by Xtext 2.27.0
 */
package at.ac.tuwien.big.serializer;

import at.ac.tuwien.big.services.CpsmlGrammarAccess;
import com.google.inject.Inject;
import cpsml.Actuator;
import cpsml.CPS;
import cpsml.Controller;
import cpsml.CpsmlPackage;
import cpsml.Environment;
import cpsml.Function;
import cpsml.MessageBroker;
import cpsml.MessagingLink;
import cpsml.Node;
import cpsml.Position;
import cpsml.Sensor;
import cpsml.WiredModule;
import cpsml.WirelessModule;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CpsmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CpsmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CpsmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CpsmlPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case CpsmlPackage.CPS:
				sequence_CPS(context, (CPS) semanticObject); 
				return; 
			case CpsmlPackage.CONTROLLER:
				sequence_Controller(context, (Controller) semanticObject); 
				return; 
			case CpsmlPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case CpsmlPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CpsmlPackage.MESSAGE_BROKER:
				sequence_MessageBroker(context, (MessageBroker) semanticObject); 
				return; 
			case CpsmlPackage.MESSAGING_LINK:
				sequence_MessagingLink(context, (MessagingLink) semanticObject); 
				return; 
			case CpsmlPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case CpsmlPackage.PARAMETER:
				sequence_Parameter(context, (cpsml.Parameter) semanticObject); 
				return; 
			case CpsmlPackage.POSITION:
				sequence_Position(context, (Position) semanticObject); 
				return; 
			case CpsmlPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case CpsmlPackage.WIRED_MODULE:
				sequence_WiredModule(context, (WiredModule) semanticObject); 
				return; 
			case CpsmlPackage.WIRELESS_MODULE:
				sequence_WirelessModule(context, (WirelessModule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         status=Status 
	 *         topic=EString 
	 *         runs=EInt? 
	 *         ratedRuns=EInt? 
	 *         function+=Function 
	 *         function+=Function*
	 *     )
	 * </pre>
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CPS returns CPS
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         environment+=Environment 
	 *         environment+=Environment* 
	 *         messageBroker+=MessageBroker 
	 *         messageBroker+=MessageBroker* 
	 *         controller+=Controller 
	 *         controller+=Controller*
	 *     )
	 * </pre>
	 */
	protected void sequence_CPS(ISerializationContext context, CPS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Controller returns Controller
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         description=EString 
	 *         topics+=EString 
	 *         topics+=EString* 
	 *         subscription+=MessagingLink 
	 *         subscription+=MessagingLink* 
	 *         publication+=MessagingLink 
	 *         publication+=MessagingLink*
	 *     )
	 * </pre>
	 */
	protected void sequence_Controller(ISerializationContext context, Controller semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (name=EString node+=Node node+=Node*)
	 * </pre>
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     ((returnDataType=DataType hasReturn?='::')? name=EString (parameter+=Parameter parameter+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnectableElement returns MessageBroker
	 *     MessageBroker returns MessageBroker
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         position=Position 
	 *         topics+=EString 
	 *         topics+=EString* 
	 *         connectionModule+=ConnectionModule 
	 *         connectionModule+=ConnectionModule*
	 *     )
	 * </pre>
	 */
	protected void sequence_MessageBroker(ISerializationContext context, MessageBroker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MessagingLink returns MessagingLink
	 *
	 * Constraint:
	 *     (topics+=EString topics+=EString* messageBroker=[MessageBroker|EString])
	 * </pre>
	 */
	protected void sequence_MessagingLink(ISerializationContext context, MessagingLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Node
	 *     ConnectableElement returns Node
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         status=Status 
	 *         position=Position 
	 *         component+=Component 
	 *         component+=Component* 
	 *         connectionModule+=ConnectionModule 
	 *         connectionModule+=ConnectionModule* 
	 *         (subscription+=MessagingLink subscription+=MessagingLink*)? 
	 *         (publication+=MessagingLink publication+=MessagingLink*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (dataType=DataType name=EString)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, cpsml.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CpsmlPackage.Literals.PARAMETER__DATA_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CpsmlPackage.Literals.PARAMETER__DATA_TYPE));
			if (transientValues.isValueTransient(semanticObject, CpsmlPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CpsmlPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getDataTypeDataTypeEnumRuleCall_0_0(), semanticObject.getDataType());
		feeder.accept(grammarAccess.getParameterAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Position returns Position
	 *
	 * Constraint:
	 *     (x=EFloat y=EFloat z=EFloat)
	 * </pre>
	 */
	protected void sequence_Position(ISerializationContext context, Position semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CpsmlPackage.Literals.POSITION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CpsmlPackage.Literals.POSITION__X));
			if (transientValues.isValueTransient(semanticObject, CpsmlPackage.Literals.POSITION__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CpsmlPackage.Literals.POSITION__Y));
			if (transientValues.isValueTransient(semanticObject, CpsmlPackage.Literals.POSITION__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CpsmlPackage.Literals.POSITION__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositionAccess().getXEFloatParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getPositionAccess().getYEFloatParserRuleCall_6_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getPositionAccess().getZEFloatParserRuleCall_9_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         status=Status 
	 *         topic=EString 
	 *         function+=Function 
	 *         function+=Function* 
	 *         frequency=EFloat?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnectionModule returns WiredModule
	 *     WiredModule returns WiredModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         supportedProtocols+=Protocol 
	 *         supportedProtocols+=Protocol* 
	 *         (connect+=[WiredModule|EString] connect+=[WiredModule|EString]*)? 
	 *         (connectOpposite+=[WiredModule|EString] connectOpposite+=[WiredModule|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_WiredModule(ISerializationContext context, WiredModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnectionModule returns WirelessModule
	 *     WirelessModule returns WirelessModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         supportedProtocols+=Protocol 
	 *         supportedProtocols+=Protocol* 
	 *         range=EFloat 
	 *         (connect+=[WirelessModule|EString] connect+=[WirelessModule|EString]*)? 
	 *         (connectOpposite+=[WirelessModule|EString] connectOpposite+=[WirelessModule|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_WirelessModule(ISerializationContext context, WirelessModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
